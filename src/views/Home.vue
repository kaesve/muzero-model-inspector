<template>
  <div
    class="home side-by-side"
    @dragenter.stop.prevent
    @dragover.stop.prevent
    @drop.stop.prevent="drop"
  >
    <div class="InspectorPanel">
      <h1>MuZero experiment inpsector</h1>
      <p>
        This tool can be used to visualize an explore the data generated by our <a href="https://github.com/kaesve/muzero">MuZero implementation</a>. Our tool currently expects data from the MountainCar Gym environment. Support for other environments will be added later. We can only visualize latent spaces with 3 dimensions or 4 dimensions (by slicing in one dimension).
      </p>

      <section>
        <h2>Experiments</h2>
        <span v-if="loading">loading..</span>
        <ul v-else>
          <li><button @click="loadData('data/plotdata_l4.json')">4D latent space -- no regularisation</button></li>
          <li><button @click="loadData('data/plotdata_l4_dec.json')">4D latent space -- decoder regularisation</button></li>
          <li><button @click="loadData('data/plotdata_l4_kl.json')">4D latent space -- KL regularisation</button></li>
        </ul>
      </section>
      
      <form @submit.prevent>
        <div>
          <label>
            Map:
            <select v-model="color">
              <optgroup label="Structural:">
                <option value="horizontal bands">Horizontal Bands</option>
                <option value="vertical bands">Vertical Bands</option>
                <option value="uv">UV</option>
                <option value="xy">XYZ</option>
              </optgroup>
              <optgroup v-if="colorMaps" label="Value maps">
                <option 
                  v-for="(gr, name) in colorMaps" :key="name" :value="name">
                  {{name}}
                </option>
              </optgroup>
            </select>
          </label>
          <p v-if="color == 'horizontal bands'">
            Points are colored by alternating between black and white for each sampled <code>ΔX</code> value in the input space.
          </p>
          <p v-else-if="color == 'vertitcal bands'">
            Points are colored by alternating between black and white for each sampled <code>X</code> value in the input space.
          </p>
          <p v-else-if="color == 'uv'">
            Each point is colored according to its coordinates in the normalized input space (or UV space). The X and Y components of the position of the point in the input space are normalized and used as the Red and Green components of the color. The Blue component is set to a fixed value.
          </p>
          <p v-else-if="color == 'xy'">
            Each point is colored according to its coordinates in the embedding space. The XYZ components of the position of the point in embedding space are used as the RGB components of the color.
          </p>
          <p v-else-if="color == ''">
          </p>
        </div>
        <fieldset>
          <legend>Latent space</legend>
          <span>Dimensions: 4</span>
          <label>
            Shown dimensions: [ {{ axes.map(i => i + 1).join(", ")}} ]
          </label>
          <label>
            Apply PCA:
            <input type="checkbox" v-model="usePCA" />
          </label>
          <p>
            <label>
              Slice dimension: 
              <select v-model="sliceAxis">
                <option v-for="i in [0, 1, 2, 3]" :value="i" :key="i">{{i + 1}}</option>
              </select>
            </label>
            <label>At:
              <input type="number" min="0" max="1" step="0.01" v-model="sliceAt" />
              <input type="range" min="0" max="1" step="0.01" v-model="sliceAt" />
            </label>
          </p>
        </fieldset>
        
        <div v-if="trajectories && trajectorySet">
          <label>
            Observation frequency:
            <select v-model="trajectorySetIndex">
              <option v-for="(t,i) in trajectories" :key="i" :value="i">
                every {{t.test_sparsity}} steps
              </option>
            </select>
          </label>
          <label>
            Run:
            <select v-model="trajectoryIndex">
              <option v-for="(_,i) in trajectorySet.states" :key="i" :value="i">
                {{i}} ({{trajectorySet.rewards[i]}})
              </option>
            </select>
          </label>
          <label>
            Dynamics:
            <select v-model="dynamicsIndex">
              <option v-for="(t,i) in trajectorySet.dynamics" :key="i" :value="i">
                every {{t.test_sparsity}} steps
              </option>
            </select>
          </label>

          <ol class="trajectory-action-list">
            <li
              v-for="(a, i) in trajectoryActions" :key="i"
              @mouseenter="cursorFromTrajectory(i)"
            >
              <span class="action-index">{{i}}</span>
              <span class="action-mark">{{"◀◈▶"[a]}}</span>
            </li>
          </ol>
        </div>
      </form>

      
      <div class="StateSpace_container">
        <div class="inputContainer">
          <canvas ref="inputCanvas" class="input-canvas" @mousemove="moveCursor"></canvas>
          <canvas ref="overlayCanvas" class="overlay-canvas"></canvas>

          <ol class="tick-list x-ticks">
            <li v-for="tick in ticks" :key="tick[0]"><span>{{tick[0]}}</span></li>
          </ol>
          <span class="AxisLabel AxisLabel--horizontal">X</span>
          <ol class="tick-list y-ticks">
            <li v-for="tick in ticks" :key="tick[1]">{{tick[1]}}</li>
          </ol>
          <span class="AxisLabel AxisLabel--vertical"><span>ΔX</span></span>
        </div>

        <div class="RenderedState_container">
          <mountaincar-renderer class="RenderedState" :state="state" />
          
          <div v-if="cursor">
            <dl>
              <dt> X</dt><dd>{{state[0] < 0 ? "" : " "}}{{state[0].toFixed(2)}}</dd>
              <dt>ΔX</dt><dd>{{state[1] < 0 ? "" : " "}}{{state[1].toFixed(2)}}</dd>
            </dl>
          </div>
        </div>
      </div>


    </div>
    <div ref="canvasContainer"></div>
  </div>
</template>

<script>
// @ is an alias to /src
import HelloWorld from '@/components/HelloWorld.vue'

import MountaincarRenderer from "@/components/mountaincarRenderer.vue";

import axios from "axios";
import cm from "colormap";

// This will get big, and we don't want vue to observe this data
let cache = {};
window.cache = cache;


function trajectoryTube(t) {
  let curve = new THREE.CurvePath();
  t = t.map(v => v.flat());
  t.forEach((v, j) => {
    if (j) {
      curve.add(new THREE.LineCurve3(
        new THREE.Vector3(...t[j - 1].flat()),
        new THREE.Vector3(...t[j].flat())
      ));
    }
  });
  // curve.arcLengthDivisions = t.length - 1;
  let geom = new THREE.TubeGeometry(curve, 5*(t.length - 1), 0.005, 8);
  return geom;
}

export default {
  name: 'Home',
  components: { MountaincarRenderer },
  data() {
    return {
      color: "uv",

      ctx: null,
      overlayCtx: null,

      id: null,
      loading: false,

      state: [ 0, 0 ],

      sliceAxis: 3,
      sliceAt: 0,
      // axes: [ 0, 1, 2 ],
      usePCA: false,

      scene: null,
      renderer: null,
      loopHandle: null,
      mesh: null,
      geometry: null,
      cursor: null,
      cursor2: null,
      trajectoryMeshes: [],

      manifoldOpacity: 0.9,

      dirty: {
        manifold: false,
        colors: false,
        trajectories: false,
      },

      offset: null,
      camControls: null,

      trajectorySetIndex: 0,
      trajectoryIndex: 0,
      dynamicsIndex: 0,


    }
  },
  mounted() {
    window.comp = this;

    let inputCanvas = this.$refs.inputCanvas;
    this.ctx = inputCanvas.getContext("2d");
    this.overlayCtx = this.$refs.overlayCanvas.getContext("2d");

    const renderer = this.renderer = window.renderer = new THREE.WebGLRenderer();
    renderer.setClearColor(new THREE.Color(0xbbbbbb), 1);
    this.$refs.canvasContainer.appendChild( renderer.domElement );
    renderer.domElement.classList.add("latent-canvas")

    const scene = this.scene = new THREE.Scene();
    const directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
    // scene.add( directionalLight );
    const ambientLight = new THREE.AmbientLight( 0xffffff, 1 );
    scene.add( ambientLight );

    const sphereGeom = new THREE.SphereGeometry( 0.015, 8, 8 );
    const cursorMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
    const cursor = this.cursor = new THREE.Mesh( sphereGeom, cursorMaterial );
    cursor.visible = false;
    scene.add( cursor );
    
    const sphereGeom2 = new THREE.SphereGeometry( 0.015, 8, 8 );
    const cursorMaterial2 = new THREE.MeshBasicMaterial( { color: 0xff00ff } );
    const cursor2 = this.cursor2 = new THREE.Mesh( sphereGeom2, cursorMaterial2 );
    cursor2.visible = false;
    scene.add( cursor2 );

    const unitCubeGeom = new THREE.BoxGeometry(1, 1, 1);
    const unitCubeMaterial = new THREE.MeshBasicMaterial( { color: 0xaaaaaa, side: THREE.BackSide } );
    const unitCube = new THREE.Mesh( unitCubeGeom, unitCubeMaterial );
    // scene.add(unitCube);

    const camera = new THREE.PerspectiveCamera( 75, 1, 0.1, 10 );
    camera.position.z = 2;
    const controls = this.camControls = new OrbitControls( camera, renderer.domElement );

    let animate = () => {
      this.loopHandle = requestAnimationFrame( animate );

      if (this.dirty.manifold) {
        this.updateManifold();
        this.dirty.manifold = false;
      }
      if (this.dirty.trajectories) {
        this.updateTrajectories();
        this.dirty.trajectories = false;
      }
      if (this.dirty.colors) {
        this.updateColors();
        this.dirty.colors = false;
      }

      const canvas = renderer.domElement;
      // look up the size the canvas is being displayed
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;

      // adjust displayBuffer size to match
      if (canvas.width !== width || canvas.height !== height) {
        // you must pass false here or three.js sadly fights the browser
        renderer.setSize(width, height, false);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();

        // update any render target sizes here
      }

      controls.update();
      renderer.render( scene, camera );
    };

    this.loopHandle = animate();


    this.loadData("data/plotdata_l4_kl.json");
  },
  destroyed() {
    cancelAnimationFrame(this.loopHandle);
    delete cache[this.id];
  },

  computed: {
    axes() { return [ 0, 1, 2, 3 ].filter(i => i != this.sliceAxis); },
    embeddingTranslate() {
      if (!this.id || !this.usePCA)
        return [ 0, 0, 0, 0 ];
      else
        return cache[this.id].manifold.projection.mean;
    },

    embeddingTransform() {
      if (!this.id || !this.usePCA)
        return I4x4;
      else
        return cache[this.id].manifold.projection.components;
    },

    colorMaps() {
      if(!this.id) return null;
      return cache[this.id].manifold.colors;
    },
    selectedValueRange() {
      let data = cache[this.id]; // This line also makes this computed property observe the id, so it will automatically update

      if (this.color in data.manifold.colors) {
        let val = data.manifold.colors[this.color];
        let min = val[0], max = val[0];

        for (let i = 1; i < val.length; i++) {
          const v = val[i];
          min = Math.min(min, v);
          max = Math.max(max, v); 
        }
        return [ min, max ];
      }
      return null;
    },

    ticks() {
      if (!this.id) return [];

      let [ dmin, dmax ] = cache[this.id].input_domain;
      
      let range = sub(dmax, dmin);
      let ticks = [];
      for (let i = 0; i <= 10; ++i) {
        let t = add(dmin, scl(range, i/10));
        t = t.map(_t => _t.toFixed(2));
        ticks.push(t);
      }
      return ticks;
    },

    trajectories() {
      if (!this.id) return [];
      return cache[this.id].trajectories;
    },
    trajectorySet() {
      if (!this.id) return null;
      return cache[this.id].trajectories[this.trajectorySetIndex];
    },
    trajectoryActions() {
      if (!this.trajectorySet) return [];
      return this.trajectorySet.actions[this.trajectoryIndex];
    }

  },
  watch: {
    color() { this.dirty.colors = true; },
    id(newId, oldId) { 
      // delete cache[oldId];

      if (!newId) {
        this.cursor.position.fromArray([ 0, 0, 0 ]);
        this.cursor.visible = true;
        let toRemove = [ this.mesh, ...this.trajectoryMeshes ];
        this.scene.remove(...toRemove);;
        toRemove.forEach(mesh => mesh.geometry.dispose());
        this.trajectoryMeshes = [];
      } else {
        let { manifold, shape, trajectories } = cache[newId];
        let { embedding, colors } = manifold;

        this.$refs.inputCanvas.width = shape[X];
        this.$refs.inputCanvas.height = shape[Y];
        
        
        this.dirty.manifold = true;
        this.dirty.trajectories = true;
        this.dirty.colors = true;
      }
      this.renderOverlay();
    },
    state() { this.renderOverlay(); },
    trajectoryIndex() { this.dirty.trajectories = true; },
    trajectorySet() { this.dirty.trajectories = true; },
    dynamicsIndex() { this.dirty.trajectories = true; },
    usePCA() {
      this.dirty.manifold = true;
      this.dirty.trajectories = true;
      this.dirty.colors = true;
    },
    axes() {
      this.dirty.manifold = true;
      this.dirty.trajectories = true;
    },
    sliceAt() {
      this.dirty.manifold = true;
    },
    // sliceAxis() {
    //   this.updateManifold();
    //   this.updateTrajectories();
    //   this.updateColors();
    // },

  },
  methods: {
    loadData(path) {
      if (this.loading) return;

      if (path in cache) this.id = path
      else {
        this.loading = true;

        axios.get(path)
          .then(res => {
            this.parseData(res.data, path);
            this.loading = false;
          });
      }
    },
    stateToUnit(state, range) {
      let uv = div(sub(state, range[0]), sub(range[1], range[0]));
      return [ uv[0], 1 - uv[1] ];
    },
    drop(e) {
      if (e.dataTransfer && e.dataTransfer.files.length > 0) {
        this.id = null;
        this.color = "uv";

        console.log(e.dataTransfer.files);
        let f = e.dataTransfer.files[0];
        let reader = new FileReader()
        reader.onload = (loadEvent => {
          this.parseData(JSON.parse(loadEvent.target.result));
        });
        reader.onerror = err => {
          console.error(err)
        }
        reader.readAsText(f);
      }
    },
    renderOverlay() {
      let ctx = this.overlayCtx;

      let canvas = ctx.canvas;
      let canvasRect = canvas.getBoundingClientRect();


      let cdim = [ canvas.width, canvas.height ] = [ canvasRect.width, canvasRect.height ];
      ctx.clearRect(0, 0, ...cdim);

      if (this.trajectorySet) {
        let { trajectories, input_domain, shape } = cache[this.id];
        ctx.save();

        let s =  div(cdim, shape);
        // ctx.scale(...div(cdim, shape));

        ctx.lineWidth = 1
        let t = this.trajectorySet;
        t = t.states[this.trajectoryIndex].flat(2);
        

        
        ctx.beginPath();
        t.forEach((p, i) => {
          p = this.stateToUnit(p, input_domain);
          p = mul(p, shape);
          p = mul(p, s);
          if (i) ctx.lineTo(...p);
          else ctx.moveTo(...p);
        });
        ctx.strokeStyle = "rgba(255,255,255, .75)";
        ctx.lineWidth = 6;
        ctx.stroke();
        ctx.strokeStyle = "black";
        ctx.lineWidth = 1;
        ctx.stroke();

        
        let actionPalette = [
          "#aa0000",
          "#00ff00",
          "#0000ff",
          "#ffff00",
          "#00ffff",
          "#f0f0f0",
          "#0f0f0f"
        ];
        ctx.lineWidth = 1;
        ctx.miterLimit = 4;
        ctx.strokeStyle = "rgba(255,255,255, .75)";

        ctx.font = "400 6px monospace";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        t.forEach((p, i) => {
          p = this.stateToUnit(p, input_domain);
          p = mul(p, shape);
          ctx.fillStyle = actionPalette[this.trajectoryActions[i]];
          // ctx.beginPath();
          // ctx.arc(...mul(p, s), 2, 0, TAU);
          // ctx.fill();

          let char = "◀◈▶"[this.trajectoryActions[i]];
          ctx.strokeText(char, ...mul(p, s));
          ctx.fillText(char, ...mul(p, s));
        });
        

        
        let uv = this.stateToUnit(this.state, input_domain);


        ctx.beginPath();
        ctx.arc(...mul(mul(uv, s), shape), 3, 0, TAU);
        ctx.lineWidth = 2;
        ctx.strokeStyle = "white";
        ctx.stroke();
        ctx.fillStyle = "red";
        ctx.fill();

        ctx.restore();
      }


    },
    moveCursor(event) {
      if (this.id) {
        const { manifold, shape, input_domain } = cache[this.id];

        let screenP = [ event.clientX, event.clientY ];
        let screenRect = event.target.getBoundingClientRect();
        let p = sub(screenP, [ screenRect.left, screenRect.top ]);
        let uv = div(p, [ screenRect.width, screenRect.height ]);
        uv = [uv[X], 1 - uv[Y]];
        let v = mul(uv, sub(shape, [1, 1])).map(Math.floor);
        let i = v[X] + (shape[Y] - 1 - v[Y])*shape[X];

        this.state = add(input_domain[0], mul(sub(input_domain[1], input_domain[0]), uv));
        this.state = add(input_domain[0], mul(sub(input_domain[1], input_domain[0]), div(v, shape)));
  
        let _i = v[X] + v[Y]*shape[X];
        this.cursor.visible = true;
        this.cursor.position.fromArray(this.transformPoint(manifold.embedding[_i]));

        this.cursor2.visible = false;
      }

    },
    cursorFromTrajectory(i) {
      if (this.trajectorySet) {
        this.state = this.trajectorySet.states[this.trajectoryIndex][i].flat(2);

        this.cursor.visible = true;
        this.cursor.position.fromArray(
          this.transformPoint(this.trajectorySet.embeddings[this.trajectoryIndex][i].flat()));

        this.cursor2.visible = true;
        this.cursor2.position.fromArray(
          this.transformPoint(this.trajectorySet.dynamics[this.dynamicsIndex].value[this.trajectoryIndex][i].flat()));
      }
    },
    transformPoint(v) {

      v = v4m4x4(sub4(v, this.embeddingTranslate), this.embeddingTransform);
      return [
        v[this.axes[0]],
        v[this.axes[1]],
        v[this.axes[2]],
      ];
    },
    parseData(data, path = false) {
      let id = path;

      if (!path) { // in case data was dropped on here
        id = Math.random().toString(16);
        while (id in cache) id += Math.random().toString(16);
      }

      let d = Math.round(Math.sqrt(data.manifold.embedding.length));
      data.shape = [d, d];

      cache[id] = data;
      this.id = id;
    },

    updateManifold() {
      if (!this.id) return;

      let { shape } = cache[this.id];
      let t0 = Date.now();
      console.log("transform", Date.now() - t0);
      // data.manifold.embedding = embedding;


      if (false) {
        if (this.geometry) this.geometry.dispose();
        if (this.mesh) this.scene.remove(this.mesh);

        let embedding = cache[this.id].manifold.embedding.map(this.transformPoint);

        var verts = new Float32Array(embedding.flat());
        let geometry = this.geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(verts, 3));
  
        let indices = new Array(shape[X] * shape[Y] * 2 * 3);
        for (let y = 0; y < shape[Y] - 1; ++y) {
          for (let x = 0; x < shape[X] - 1; x++) {
            let i = y*shape[X]*3*2 + x*3*2;
            indices[i + 0] = x + 0 + (y + 0)*shape[X];
            indices[i + 1] = x + 1 + (y + 0)*shape[X];
            indices[i + 2] = x + 0 + (y + 1)*shape[X];
  
            i += 3;
            indices[i + 0] = x + 0 + (y + 1)*shape[X];
            indices[i + 1] = x + 1 + (y + 0)*shape[X];
            indices[i + 2] = x + 1 + (y + 1)*shape[X];
            
          }
        }
        geometry.setIndex(indices);
        // geometry.center();
        geometry.computeBoundingBox();
        geometry.computeVertexNormals();
        var material = new THREE.MeshPhongMaterial( {
          // vertexColors: true,
          side: THREE.DoubleSide,
          // transparent: true,
          // opacity: 0.75
        } );
        // const material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
        var mesh = this.mesh = new THREE.Mesh( geometry, material );
  
        this.offset = this.mesh.localToWorld(geometry.boundingBox.getCenter());
  
        this.camControls.target.copy(this.offset);
  
        this.scene.add(mesh);
      } else {
        let embedding = cache[this.id].manifold.embedding;

        if (!this.mesh || !(this.mesh instanceof THREE.InstancedMesh) || this.mesh.count != embedding.length) {
          if (this.geometry) this.geometry.dispose();
          if (this.mesh) this.scene.remove(this.mesh);
  
          let geometry = this.geometry = new THREE.SphereBufferGeometry( 0.005, 8, 8 );
          let material = new THREE.MeshPhongMaterial();
          let mesh = this.mesh = new THREE.InstancedMesh(geometry, material, shape[X]*shape[Y]);
          this.scene.add(mesh);
        }
        let { geometry, mesh } = this;

        let m = new THREE.Matrix4();
        for (let y = 0; y < shape[Y]; ++y) {
          for (let x = 0; x < shape[X]; x++) {
            let i = x + y*shape[X];

            if (abs(this.sliceAt - embedding[i][this.sliceAxis]) > 0.01)
              m.makeScale(0, 0, 0);
            else
              m.makeTranslation(...embedding[i]);

            mesh.setMatrixAt(i, m);
          }
        }

        mesh.instanceMatrix.needsUpdate = true;

        this.camControls.target.copy(new THREE.Vector3(...this.transformPoint([ 0.5, 0.5, 0.5, 0.5 ])));
      }
    },

    updateTrajectories() {
      if (!this.trajectorySet) return;


      this.scene.remove(...this.trajectoryMeshes);
      this.trajectoryMeshes.forEach(mesh => mesh.geometry.dispose());
      
      let _colors = [
        0x555555,
        0xff0000
      ];

      let t = this.trajectorySet;
      
      let embeddingTrajectory = t.embeddings[this.trajectoryIndex];
      embeddingTrajectory = embeddingTrajectory.map(v => this.transformPoint(v.flat()));
      let embeddingTube = trajectoryTube(embeddingTrajectory);
      var embeddingMat = new THREE.MeshPhongMaterial( { color: 0xffaaff } );
      let embeddingMesh = new THREE.Mesh( embeddingTube, embeddingMat );
      this.scene.add(embeddingMesh);

      let dynamicsTrajectory = t.dynamics[this.dynamicsIndex].value[this.trajectoryIndex];
      dynamicsTrajectory = dynamicsTrajectory.map(v => this.transformPoint(v.flat()));
      let dynamicsTube = trajectoryTube(dynamicsTrajectory);
      var dynamicsMat = new THREE.MeshPhongMaterial( { color: 0x55aaff } );
      let dynamicsMesh = new THREE.Mesh( dynamicsTube, dynamicsMat );
      this.scene.add(dynamicsMesh);
      this.trajectoryMeshes = [ embeddingMesh, dynamicsMesh ];


      this.renderOverlay();
    },

    updateColors() {
      if (!this.id) return;

      let { shape, manifold } = cache[this.id];
      let { colors } = manifold;
      

      var newColors = new Array(shape[X]*shape[Y]*3); // 3 components for each point

      var img = new ImageData(shape[X], shape[Y]); // could probably reuse this.

      var scale = cm({
          colormap: 'viridis',
          nshades: 100,
          format: 'float',
          alpha: 1
      });

      for (let y = 0; y < shape[Y]; ++y) {
        for (let x = 0; x < shape[X]; ++x) {
          let i = y*shape[X] + x;
          let j = 3*i;
          let k = 4*i;

          switch (this.color) {
            case "horizontal bands": {
              newColors[j + R] = 0.2 + 0.8*(y%2);
              newColors[j + G] = 0.2 + 0.8*(y%2);
              newColors[j + B] = 0.2 + 0.8*(y%2);
            } break;
            
            case "vertical bands": {
              newColors[j + R] = 0.2 + 0.8*(x%2);
              newColors[j + G] = 0.2 + 0.8*(x%2);
              newColors[j + B] = 0.2 + 0.8*(x%2);
            } break;

            case "uv": {
              newColors[j + R] = x/shape[X];
              newColors[j + G] = y/shape[Y];
              newColors[j + B] = 0.2;
            } break;
            
            case "xy": {
              let _i = (shape[Y] - 1 - y)*shape[X] + x;
              let v = this.transformPoint(manifold.embedding[_i]);
              newColors[j + R] = v[X];
              newColors[j + G] = v[Y];
              newColors[j + B] = v[Z];
            } break;

            default: {

              if (!this.selectedValueRange) {
                console.error("uh oh");
                break;
              }

              let [ min, max ] = this.selectedValueRange;

              let _i = (shape[Y] - 1 - y)*shape[X] + x;
              let vs = colors[this.color];
              let v = (vs[_i] - min) / (max - min);
              let v0 = Math.floor(v*99);
              let v1 = Math.ceil(v*99);
              let vt = v*99 - v0;

              let c = mix3(scale[v0], scale[v1], vt);


              newColors[j + R] = c[R];
              newColors[j + G] = c[G];
              newColors[j + B] = c[B];
              
            } break;

          }
        }
      }

      for (let y = 0; y < shape[Y]; ++y) {
        for (let x = 0; x < shape[X]; ++x) {
          let i = (shape[Y] - y - 1)*shape[X] + x;
          let j = 3*i;
          let k = 4*i;

          let _i = y*shape[X] + x;
          let _j = 3*_i;
          let _k = 4*_i;

          img.data[k + R] = Math.floor(255*newColors[j + R]);
          img.data[k + G] = Math.floor(255*newColors[j + G]);
          img.data[k + B] = Math.floor(255*newColors[j + B]);
          img.data[k + A] = 255;

        }
      }

      if (this.mesh instanceof THREE.InstancedMesh) {
        for (let y = 0; y < shape[Y]; ++y) {
          for (let x = 0; x < shape[X]; ++x) {
            let i = y*shape[X] + x;
            let _i = (shape[Y] - y - 1)*shape[X] + x;
            let c = new THREE.Color(
              newColors[3*_i + R],
              newColors[3*_i + G],
              newColors[3*_i + B],
            )
            this.mesh.setColorAt( i, c);
          }
        }
        this.mesh.instanceColor.needsUpdate = true;
      } else {
        this.geometry.setAttribute( "color", new THREE.BufferAttribute(new Float32Array(newColors), 3));
      }

      this.ctx.putImageData(img, 0, 0);
    }
  }
};
</script>

<style lang="scss">

*, :before, :after {
  box-sizing: border-box;
}

body {
  font: 400 12px/1.5 "Roboto", sans-serif; 
}

p {
  margin-bottom: 24px;
  max-width: 80ch;
}

h1 {
  font-weight: 800;
  line-height: 1;
  margin-bottom: 6px;
}

select, input { margin-right: 2px; }

input[type=number] {
  width: 6ch;
}
input[type=range] {
  vertical-align:  middle;
}

input[type=checkbox] {
  vertical-align: text-top;
}

.home {
  height: 100vh;
}

.side-by-side {
  display: flex;

  & > * { flex: 1 1 50%; }
}


.InspectorPanel {
  padding: 12px;
  height: 100%;
  overflow: auto;
}

.latent-canvas {
  width: 100%;
  height: 100%;
}

.StateSpace_container {
  display: flex;;
}

.RenderedState_container {
  margin-right: 24px;
  display: flex;
  flex-direction: column;
  align-items: center;

  dl {
    line-height: 1;
    align-items: baseline;
    dd {
      font-family: "Roboto Mono", monospace;
      white-space: pre;
    }
    dt {
      text-align: right;
      margin: 0 2px;
      &:after { content: ":"; }
    }
  }
}
.RenderedState {
  width: 100%;
}



.inputContainer {
  display: inline-block;;
  position: relative;
  margin: 6px 12px 36px 48px;
}

.input-canvas {
  image-rendering: pixelated;
  width: 400px;
}

.overlay-canvas {
  position: absolute;
  width: 100%;
  height: 100%;
  top: 0;
  pointer-events: none;;
}


.AxisLabel {
  position: absolute;
  display: grid;
  justify-content: center;
  align-content: center;
  font-size: small;
}

.AxisLabel--horizontal {
  width: 100%;
  margin-top: 18px
}

.AxisLabel--vertical {
  top: 0;
  margin-right: 36px;
  right: 100%;
  height: 100%;
  line-height: 0;
  width: 0;

  span {
    transform: rotateZ(-.2501turn); // anti-aliassing seems to look slightly nicer when not turned exactly 90deg
  }
}

.tick-list {
  position: absolute;
  display: flex;
  list-style: none;
  font-size: 10px;
  font-family: "Roboto Condensed";
  user-select: none;

  li {
    position: relative;
    text-align: center;
    &:after {
      content: "";
      position: absolute;
      display: block;
      background: black;
    }
  }
}

.x-ticks {
  width: calc(100% - 1px);
  justify-content: space-between;

  li {
    width: 0;
    padding-top: 5px;
    span {
      position: absolute;
      transform: translateX(-50%);
    }
  }
  li:after {
    width: 1px; height: 5px;
    top: 0; left: 0; 
  }
}

.y-ticks {
  top: 0; right: 100%;
  flex-direction: column-reverse;
  height: calc(100% - 1px);
  justify-content: space-between;

  li {
    height: 0; padding-right: 7px;
    line-height: 0;
  }
  li:after {
    width: 5px; height: 1px;
    top: 0; right: 0; 
  }
}


.trajectory-action-list {
  display: flex;
  font-size: 8px;
  overflow: auto;
  width: 100%;

  list-style: none;

  li {
    position: relative;
    width: 1.2em;
    flex: 0 0 auto;
    text-align: center;

    * { pointer-events: none;}
  }

  .action-index {
    display: block;
    visibility: hidden;
  }
  li:nth-child(5n + 1) {
    background: palegoldenrod;
  }
  li:nth-child(5n + 1) .action-index {
    visibility: visible;
  }
}
</style>
